<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>ES6 学习笔记(3) | QINGGUOING</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="紧接上篇，篇幅太长。主要讲述 Promise，异步操作和 async 函数，Class，修饰器和 Module。">
<meta name="keywords" content="ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6 学习笔记(3)">
<meta property="og:url" content="https://qingguoing.com/2017/10/10/ES6-学习笔记-3/index.html">
<meta property="og:site_name" content="QINGGUOING">
<meta property="og:description" content="紧接上篇，篇幅太长。主要讲述 Promise，异步操作和 async 函数，Class，修饰器和 Module。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-29T15:01:39.331Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6 学习笔记(3)">
<meta name="twitter:description" content="紧接上篇，篇幅太长。主要讲述 Promise，异步操作和 async 函数，Class，修饰器和 Module。">
  
    <link rel="alternate" href="/atom.xml" title="QINGGUOING" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">QINGGUOING</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qingguoing.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ES6-学习笔记-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/10/ES6-学习笔记-3/" class="article-date">
  <time datetime="2017-10-10T08:02:29.000Z" itemprop="datePublished">2017-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ES6 学习笔记(3)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>紧接上篇，篇幅太长。主要讲述 Promise，异步操作和 async 函数，Class，修饰器和 Module。</p>
<a id="more"></a>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 是一个对象，用来传递异步操作的消息。代表了某个未来才会知道结果的事件，并且这个事件提供统一的 API，可供进一步处理。Promise 对象有以下两个特点：</p>
<p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有3种状态: Pending、Resolved、Rejected。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>
<p>一旦状态改变就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。当改变已经发生，再对 Promise 对象添加回调函数，也会立即得到这个结果。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Promise 对象是一个构造函数，接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject，用来生成 Promise 实例。resolve 和 reject 是两个函数，有 javascript 引擎提供，不用自己部署。resolve 函数的作用是，将 Promise 对象的状态从 pending 变为 resolved，在异步操作成功时调用，并将异步操作的结果作为参数传递出去；reject 函数是从 pending 变为 rejected，在异步操作失败时调用，并将异步操作爆出的错误作为参数传递出去。Promise 实例生成以后，可以用 then 方法分别指定 Resolved 和 Rejected 状态的回调函数。</p>
<p>如果调用 resolve 和 reject 函数时带有参数，那么这些参数会被传给回调函数。reject 函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数除了正常的值外，还可能是另一个 Promise 实例，表示异步操作的结果有可能是一个值，也有可能是一个异步操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(p1));</span><br></pre></td></tr></table></figure>
<p>此时，p1 的状态会传递给 p2。即 p1 的状态决定了 p2 的状态。如果 p1 的状态是 pending，那么 p2 的回到函数就会等待 p1 的状态改变；如果 p1 的状态已经是 resolved 或 rejected，那么 p2 的回调函数就会立刻执行。</p>
<ol>
<li>Promise.prototype.then() 为 Promise 实例添加状态改变时的回调函数，返回的是一个新的 Promise 实例（注意，不是原来的那个 Promise 实例）。</li>
<li>Promise.prototype.catch() 是 Promise.prototype.then(null, rejection) 的别名，指定发生错误时的回调函数。如果 Promise 状态已经变成 resolved，再抛出错误是不会被捕获的。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。如果没有使用 catch 方法捕获，则 Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。另外，catch 方法返回的还是一个 Promise 对象。</li>
<li><p>Promise.resolve()/Promise.reject() 将现有对象转为 Promise 对象。如果参数不是具有 then 方法的对象，则返回一个新的 Promise 对象，且状态为 resolved/rejected。如果参数是一个 Promise 实例，则会被原封不动地返回。允许调用时不带参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'hello'</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.all()/Promise.race() 将多个 Promise 实例包装成一个新的 Promise 实例，就收一个数组作为参数，数组成员都是 Promise 对象的实例；如果不是，会先调用 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理（函数的参数不一定是数组，但必须具有 Iterator 接口）。</p>
</li>
</ol>
<h3 id="异步操作与-async-函数"><a href="#异步操作与-async-函数" class="headerlink" title="异步操作与 async 函数"></a>异步操作与 async 函数</h3><p>ES6 诞生前，异步编程的方法大概有下面4种：</p>
<ol>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ol>
<p>ES7 提供了 async 函数，使得异步操作变的更加方便。而 async 函数就是 Generator 函数的语法糖，将 Generator 函数的星号(*)替换成 async，将 yield 替换成 await。async 函数对 Generator 函数的改进体现在以下4点:</p>
<ol>
<li>内置执行器。async 函数自带执行器。而 Generator 函数需要调用 next 方法或者自动执行器才能真正执行。</li>
<li>更好的语义。</li>
<li>更广的适用性。async 函数的 await 命令后面可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>
<li>返回值是 Promise。async 函数的返回值是 Promise 对象，而 Generator 函数的返回值是 Iterator 对象。</li>
</ol>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>JavaScript 语言的传统方法是通过构造函数定义并生成新对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码用 ES6 的 Class 改写如下。类的所有方法都定义在类的 prototype 属性上，且类内部定义的所有方法都是不可枚举的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> Point; <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h5 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h5><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时自动调用该方法。一个类必须有该方法，默认是一个空的 constructor 方法。constructor 方法默认返回实例对象（即this)，不过完全可以指定返回另外一个对象，但这会导致实例对象不是构造函数类的实例。</p>
<h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    getClassName() &#123;</span><br><span class="line">        <span class="keyword">return</span> Me.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与函数一样，Class 也可以使用表达式的形式定义。此时这个类的名字是 MyClass 而不是 Me，Me 只在 Class 的内部代码可用。如果 Class 内部没有用到，那么可以省略，而采用 Class 表达式，可以写出立即执行的 Class。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">'qingguoing'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h3><p>Class 之间可以通过 extends 关键字实现继承。子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象，而且只有调用 super 之后，才可以使用 this 关键字，否则会报错。如果子类没有定义 constructor 方法，那么这个方法会被默认添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Class 作为构造函数的语法糖，同时有 prototype 属性和 <strong>proto</strong> 属性：</p>
<ol>
<li>子类的 <strong>proto</strong> 属性表示构造函数的继承，总是指向父类。作为一个对象，子类的原型(<strong>proto</strong> 属性)是父类。</li>
<li>子类 prototype 属性的 <strong>proto</strong> 属性表示方法的继承，总是指向父类的 prototype 属性。作为一个构造函数，子类的原型是父类的实例。</li>
</ol>
<h4 id="extends-的继承目标"><a href="#extends-的继承目标" class="headerlink" title="extends 的继承目标"></a>extends 的继承目标</h4><p>extends 关键字后面可以跟多种类型的值，class B extends A {} A 是一个有 prototype 属性的函数，就能被 B 继承。由于函数都有 prototype 属性，因此 A 可以是任意函数。下面三种特殊情况：</p>
<ol>
<li><p>class A extends Object {} 此时 A 是构造函数 Object 的复制，A 的实例就是 Object 的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.__proto__ === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125; 不存在任何继承，此时 A 作为一个基类就是一个普通函数，所以继承 <span class="built_in">Function</span>.prototype。但是 A 调用后返回一个空对象即 <span class="built_in">Object</span> 实例，所以 A.prototype.__proto__ 指向构造函数(<span class="built_in">Object</span>)的 prototype属性。</span><br></pre></td></tr></table></figure>
</li>
<li><p>class A extends null {} 此时 A 是一个普通函数，直接继承 Function.prototype。但是 A 调用后返回的对象不继承任何方法，所以A的 <strong>proto</strong> 指向 Function.prototype，即实质执行了下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处若不声明 constructor，会报错，因为父类 null 没有 constructor 方法，调用默认的 super 导致出错。</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子类实例的 <strong>proto</strong> 属性的 <strong>proto</strong> 属性，指向父类实例的 <strong>proto</strong> 属性，即子类的原型的原型是父类的原型。因此，通过子类实例的 <strong>proto</strong>.<strong>proto</strong> 属性可以修改父类实例的行为。</p>
</li>
</ol>
<h4 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h4><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面几种：Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error() 和 Object()。</p>
<p>extends 关键字不仅可以用于继承类，还可用于继承原生的构造函数。因为 ES6 是先新建父类的实例对象 this，然后再用子类的构造函数修饰 this，这使得父类的所有行为都可以继承。因此可以在原生数据结构的基础上定义自己的数据结构。而 ES5 是先新建子类的实例对象 this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</p>
<h4 id="Class-的-getter-和-setter"><a href="#Class-的-getter-和-setter" class="headerlink" title="Class 的 getter 和 setter"></a>Class 的 getter 和 setter</h4><p>与 ES5 一样，在 Class 内部可以使用 get 和 set 关键字对某个属性设置存值函数和取值函数，拦截该属性的存取行为。下面代码中，prop 属性有对应的存值函数和取值函数，因此赋值和读取行为都被定义了。存值函数和取值函数是设置在属性的 descriptor 对象上的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">get</span> prop() &#123;&#125;</span><br><span class="line">    <span class="keyword">set</span> prop(value) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Class-的-Generator-方法"><a href="#Class-的-Generator-方法" class="headerlink" title="Class 的 Generator 方法"></a>Class 的 Generator 方法</h4><p>如果在某个方法前加上星号(*)，就表示该方法是一个 Generator 函数。下面的代码中，Foo 类的 Symbol.iterator 方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator 方法返回一个 Foo 类的默认遍历器，for…of循环会自动调用这个遍历器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator] &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="keyword">this</span>.args) &#123;</span><br><span class="line">            <span class="keyword">yield</span> arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Foo(<span class="string">'hello'</span>, <span class="string">'world'</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法都会被实例继承。如果在一个方法前加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类调用，称为“静态方法”。而父类的静态方法可以被子类继承。静态方法也可以从 super 对象上调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> test() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.classMethod()&#125;</span> too`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod(); <span class="comment">// hello</span></span><br><span class="line">Bar.classMethod(); <span class="comment">// hello</span></span><br><span class="line">Bar.test(); <span class="comment">// hello too</span></span><br></pre></td></tr></table></figure>
<h4 id="Class-的静态属性"><a href="#Class-的静态属性" class="headerlink" title="Class 的静态属性"></a>Class 的静态属性</h4><p>静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>ES6 明确规定，Class 内部只有静态方法，没有静态属性。而 ES7 提供的静态属性的提案，babel 转码器已支持。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> myProp = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(MyClass.myProp); <span class="comment">// 42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h4><p>new 是从构造函数生成实例的命令。ES6 为 new 命令引入了 new.target属性，(在构造函数中)返回 new 命令所作用的构造函数。如果构造函数不是通过 new 命令调用的，那么该属性的值为 undefined。因此该属性可用于确定构造函数是怎么调用的。Class 内部调用 new.target 返回当前 Class，而子类继承父类时 new.target 会返回子类。另外，在函数外部，使用 new.target 会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new生成实例'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// log: false</span></span><br></pre></td></tr></table></figure>
<h3 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h3><p>修饰器（Decorator）是一个表达式，用于修改类的行为。ES7 提案，目前 Babel 转码器已经支持。修饰器对类的行为的改变，是在代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。基本上，修饰器的行为如下，修饰器本质上是能在编译时执行的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure>
<p>修饰器函数可以接受3个参数，依次是目标对象、属性名和该属性的描述对象。后两个参数可省略。如果希望修饰器的行为能根据目标对象的不同而不同，就要在外面再封装一层。下面的代码中，修饰器 testable 可以接受参数，这就等于可以修改修饰器的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        target.isTestable = isTestable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果要为类的实例添加方法，可以在修饰器函数中为目标类的 prototype 属性添加方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法的修饰"><a href="#方法的修饰" class="headerlink" title="方法的修饰"></a>方法的修饰</h4><p>修饰器不仅可以修饰类，还可以修饰类的属性。下面中的修饰器（readonly）会修改属性的描述对象(descriptor)，然后被修改的描述对象再用来定义属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>ES6 的模块加载称为“编译时加载”，即 ES6 可以在编译时就完成模块编译，效率比 CommonJS 模块的加载方式高。模块的功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。export 命令可以出现在模块的任何位置，只要处于模块的顶层即可。另外，export 语句输出的值是动态绑定的，绑定其所在的模块。</p>
<p>import 命令具有提升效果，会提升到整个模块的头部首先执行。import 语句会执行所加载的模块。如果一个模块中先输入后输出同一个模块，import 语句可以与 export 语句写在一起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>; <span class="comment">// 仅仅执行 lodash 模块，而不输入任何值。</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure>
<h4 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h4><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">r</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">r</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; area, circumference &#125; <span class="keyword">from</span> <span class="string">'./circle'</span>; <span class="comment">// 逐一加载</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>; <span class="comment">// 整体加载</span></span><br><span class="line"><span class="built_in">module</span> 命令可以取代 <span class="keyword">import</span> 语句，达到整体输入模块的作用。<span class="built_in">module</span> 命令后面跟一个变量，表示输入的模块定义在该变量上。<span class="built_in">module</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line">#### export default</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> 命令为模块指定默认输出。一个模块只能有一个默认输出。其他模块加载该模块时，就不需要知道原模块输出的名字，<span class="keyword">import</span> 命令可以为其指定任意名字。此时，<span class="keyword">import</span> 命令后面不使用大括号。</span><br><span class="line"></span><br><span class="line">本质上，<span class="keyword">export</span> <span class="keyword">default</span> 就是输出一个叫作 <span class="keyword">default</span> 的标量或方法，然后系统允许你为它取任意名字。</span><br><span class="line"></span><br><span class="line">#### 模块的继承</span><br><span class="line">模块之间也可以继承。下文中的 <span class="keyword">export</span> * 表示输出 circle 模块的所有属性和方法。注意，<span class="keyword">export</span> * 命令会忽略 circle 模块的 <span class="keyword">default</span> 方法。</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">export * from 'circle';</span></span><br><span class="line"><span class="string">export var e = 2.718;</span></span><br><span class="line"><span class="string">export default function foo(x) &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="模块加载的实质"><a href="#模块加载的实质" class="headerlink" title="模块加载的实质"></a>模块加载的实质</h4><p>ES6 模块加载的机制与 CommonJS 模块完全不同。CommonJS 模块输出的是一个值的拷贝，即一旦输出一个值，模块内部的变化就影响不到这个值。而ES6模块输出的是值的动态的只读引用，即值指向的地址是只读的。等到真的需要用到时，再到模块中取值，原始值变了，输入值也会跟着变，而且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<h4 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h4><p>循环加载指的是 a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。</p>
<h4 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h4><p>CommonJS 的一个模块就是一个脚本文件，require 命令第一次加载该脚本就会执行整个脚本，然后在内存中生成一个对象。下面的代码中，该对象的 id 属性是模块名，exports 属性是模块输出的各个接口，loaded 表示模块的脚本是否执行完毕。其他还有很多属性，这里省略了。以后需要用到这个模块时，就会到 exports 属性上取值，即使再次执行 require 命令，也不会再次执行该模块，而是到缓存中取值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id: <span class="string">'xxx'</span>,</span><br><span class="line">    exports: &#123;&#125;,</span><br><span class="line">    loaded: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 requre 时就会全部执行。CommonJS 的做法是，一旦出现某个模块被“循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<h4 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h4><p>ES6 模块是动态引用，遇到模块加载命令 import 时不会去执行模块，只是生成一个指向被加载模块的引用，需要开发者自己保证真正取值时能够取到值。下面中的 a.js 能够执行，而改成 CommonJS 加载原理不能够执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'./b.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行完毕'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>ES6 这块东东至此算是结束了，自己也是再次回忆了一次，比第一次看时又收货了不少。其实，想总结这个系列，已经计划了大概有一年时间了吧，因为懒癌，也是拖到现在，ES8都已经发出来了，真是惭愧。。。（ES7/8 只能继续往后推，抽时间写出来了）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qingguoing.com/2017/10/10/ES6-学习笔记-3/" data-id="cjxhnmilk002zjp8cokmefqjq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/10/15/Flux架构系列-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Flux架构系列(1)
        
      </div>
    </a>
  
  
    <a href="/2017/09/25/ES6-学习笔记-2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ES6 学习笔记(2)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Babel/">Babel</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Diary/">Diary</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术论坛/">技术论坛</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Async/">Async</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/D2/">D2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EventLoop/">EventLoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flux/">Flux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/H5/">H5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS-异步处理系列/">JS 异步处理系列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/">Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/">Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/">Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/awk/">awk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/babel-plugin/">babel-plugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/koa/">koa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/learning/">learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活随笔/">生活随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Async/" style="font-size: 10px;">Async</a> <a href="/tags/D2/" style="font-size: 10px;">D2</a> <a href="/tags/ES6/" style="font-size: 16.67px;">ES6</a> <a href="/tags/EventLoop/" style="font-size: 13.33px;">EventLoop</a> <a href="/tags/Flux/" style="font-size: 13.33px;">Flux</a> <a href="/tags/H5/" style="font-size: 10px;">H5</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JS-异步处理系列/" style="font-size: 20px;">JS 异步处理系列</a> <a href="/tags/Node/" style="font-size: 10px;">Node</a> <a href="/tags/Performance/" style="font-size: 10px;">Performance</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Redux/" style="font-size: 10px;">Redux</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/awk/" style="font-size: 10px;">awk</a> <a href="/tags/babel-plugin/" style="font-size: 10px;">babel-plugin</a> <a href="/tags/koa/" style="font-size: 13.33px;">koa</a> <a href="/tags/learning/" style="font-size: 10px;">learning</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/vscode/" style="font-size: 10px;">vscode</a> <a href="/tags/生活随笔/" style="font-size: 10px;">生活随笔</a> <a href="/tags/自动化测试/" style="font-size: 10px;">自动化测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/27/自动处理对象结构中-null-字段的-babel-插件/">自动处理对象结构中 null 字段的 babel 插件</a>
          </li>
        
          <li>
            <a href="/2019/05/26/如何编写好一个测试用例/">如何编写好一个测试用例</a>
          </li>
        
          <li>
            <a href="/2019/05/20/JS-异步处理系列（四）-async-await/">JS 异步处理系列（四）- async &amp; await</a>
          </li>
        
          <li>
            <a href="/2019/05/19/JS-异步处理系列（三）-Promise/">JS 异步处理系列（三）- Promise</a>
          </li>
        
          <li>
            <a href="/2019/05/14/JS-异步处理系列（二）-Node-Event-Loop/">JS 异步处理系列（二）- Node Event Loop</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 qingguoing<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>